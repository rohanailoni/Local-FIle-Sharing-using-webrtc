<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    {{ room_name|json_script:"room-name" }}
    {{ user_name|json_script:"user-name" }}
    <div >
        <form id="fileInfo">
          <input type="file" id="fileInput" name="files"/>
        </form>
        <button disabled id="sendFile">Send</button>
        <button disabled id="abortButton">Abort</button>
      </div>
    <div class="progress">
        <div class="label">Send progress: </div>
        <progress id="sendProgress" max="0" value="0"></progress>
    </div>
    <div class="progress">
        <div class="label">Receive progress: </div>
        <progress id="receiveProgress" max="0" value="0"></progress>
      </div>
    <a id="download"></a>
    <script>
        const roomName = JSON.parse(document.getElementById('room-name').textContent);
        const userName = JSON.parse(document.getElementById('user-name').textContent);
        
        var mappeer={}
        let receiveBuffer = [];
        
        var recivedsize=0; //size of received file is default by zero
        var rec_filesize=0; //this is changed the size of the file that was sended by the peer
        var filename="";
        const downloadAnchor = document.querySelector('a#download'); // element for showing the dynamic link when the file have been recevied
        const sendProgress = document.querySelector('progress#sendProgress');
        const receiveProgress = document.querySelector('progress#receiveProgress');
        const fileInput = document.querySelector('input#fileInput');
        const sendFileButton = document.querySelector('button#sendFile');
        console.log(window.location)
        //connect to websocker connection
        const chatSocket = new WebSocket(
            'ws://'
            + window.location.hostname+':8001'
            + '/ws/chat/'
            + roomName
            + '/'
            + userName
            + '/'
        );
        chatSocket.onmessage = function(e) {
            
            const data = JSON.parse(e.data);
            var peer_username=data.peer;
            var action=data.action;
            
            if(peer_username === userName){

            }else{
                if(action==="new-peer"){
                    var channel=data.message.reciver_channel_name
                    createoffer(peer_username,channel);
                }else if(action==="new-offer"){
                    var msg=data.message.sdp
                    var channel=data.message.reciver_channel_name
                    createanswer(msg,peer_username,channel)
                }else if(action==="new-answer"){
                    var answer=data.message.sdp
                    var peer=mappeer[peer_username][0]
                    peer.setRemoteDescription(answer);
                }
            }

            
        };
        chatSocket.onopen= function(e){
            signal('new-peer',{});
            
        }
        chatSocket.onclose = function(e) {
            
            console.error('Chat socket closed unexpectedly');
        };

        fileInput.addEventListener('change', handleFileInputChange, false);
        sendFileButton.addEventListener('click', () => sendfiledata());
        //this function helps to handle change in file input such the other peers will also know the size of the input file
        async function handleFileInputChange() {
            const file = fileInput.files[0];
            if (!file) {
                console.log('No file chosen');
            } else {
                
                var send_msg={"action":"file-size","file-size":file.size,"file-name":file.name};
                console.log("send message",send_msg)
                for(var key in mappeer){
                    await mappeer[key][2].send(JSON.stringify(send_msg));
                }
                sendFileButton.disabled=false;
            }
        }
        //the main fucntion which is responsible for splitting the file into streams and sending into datachannels
        function sendfiledata(){
            var file=fileInput.files[0];
            console.log(`File is ${[file.name, file.size, file.type, file.lastModified].join(' ')}`);
            const chunkSize = 16384;
            fileReader = new FileReader();  
            sendProgress.max = file.size;
   
            let offset = 0;
            fileReader.addEventListener('error', error => console.error('Error reading file:', error));
            fileReader.addEventListener('abort', event => console.log('File reading aborted:', event));
            fileReader.addEventListener('load', e => {
                //console.log('FileRead.onload ', e.target.result);
                
                for(var key in mappeer){
                    mappeer[key][1].send(e.target.result);
                }
                sendProgress.value = offset;
                offset += e.target.result.byteLength;
                
                if (offset < file.size) {
                    readSlice(offset);
                }
            });   
            const readSlice = o => {
                console.log('readSlice ', o);
                const slice = file.slice(offset, o + chunkSize);
                fileReader.readAsArrayBuffer(slice);
            };
            readSlice(0);

        }
        //this is for creating an offer if the new peer is in the network
        function createoffer(peerusername,reciver_channel_name){
            var peer =new RTCPeerConnection(null);

            var dc_array= peer.createDataChannel('arraybuffer');
            var dc_json=peer.createDataChannel('json')
            dc_array.binaryType="arraybuffer";
            //adding event handler for arraybuffer channel
            dc_array.addEventListener('open',()=>{
                console.log("rtc connection opened for transfer of array buffer");
            });
            //adding message for arraybuffer channel
            dc_array.addEventListener('message',(e)=>{

                onrecmessagefilehandler(e);

            });
            //fopen handler for json data
            dc_json.addEventListener('open',()=>{
                console.log("rtc connection opened for transfer of json buffer");
            });
            //adding onmessage for json channel
            dc_json.addEventListener('message',(e)=>{

                const data = JSON.parse(e.data);
                console.log("data recived:-",data)
                handler(data)

            });
            mappeer[peerusername]=[peer,dc_array,dc_json];
            peer.addEventListener('iceconnectionstatechange',()=>{
                var iceconnectionstate=peer.iceConnectionState;
                if(iceconnectionstate === "failed" || iceconnectionstate === "disconnected" || iceconnectionstate === "closed"){
                    delete mappeer[peerusername];
                    if(iceconnectionstate !== "closed"){
                        peer.close();
                    }
                    
                }

            });
            peer.addEventListener('icecandidate',(event)=> {
                
                if(event.candidate !== null){
                    return;

                }
                
                signal('new-offer',{sdp:peer.localDescription,'reciver_channel_name':reciver_channel_name})


            });
            
            peer.createOffer().then(o=>peer.setLocalDescription(o)).then(()=>console.log("local description sucessfully"))
        }
        //this is for accepting the offer and return the message as accepted 
        function createanswer(offer,peerusername,reciver_ch) {
            var peer =new RTCPeerConnection(null);
            if(!mappeer[peerusername]){
                mappeer[peerusername]=[peer,null,null]
            }
            

            peer.addEventListener('datachannel',(e)=>{
                console.log("In datachannel",e,"with channel name",e.channel.label)
                var channel_name=e.channel.label
                if(channel_name==="json"){
                    peer.dc_json=e.channel
                    peer.dc_json.addEventListener('open',()=>{
                        console.log("connection opened for json channel");
                    });
                    peer.dc_json.addEventListener('message',(e)=>{
                        const data = JSON.parse(e.data);
                        console.log("data recived:-",data)
                        handler(data)
                        
                    });
                    mappeer[peerusername][2]=peer.dc_json
                }else if(channel_name==="arraybuffer"){
                    peer.dc_array=e.channel;
                    peer.dc_array.binaryType='arraybuffer';
                    recivedsize=0
                    // downloadAnchor.textContent="";
                    // downloadAnchor.removeAttribute('download');
                    // if (downloadAnchor.href) {
                    //     URL.revokeObjectURL(downloadAnchor.href);
                    //     downloadAnchor.removeAttribute('href');
                    // }
                    peer.dc_array.addEventListener('open',()=>{
                        console.log("connection opened for array buffer");
                    });
                    peer.dc_array.addEventListener('message',(e)=>{
                        onrecmessagefilehandler(e);
                        
                    });
                    mappeer[peerusername][1]=peer.dc_array
                }
                
                
                
            })

            peer.addEventListener('iceconnectionstatechange',()=>{
                var iceconnectionstate=peer.iceConnectionState;
                if(iceconnectionstate === "failed" || iceconnectionstate === "disconnected" || iceconnectionstate === "closed"){
                    delete mappeer[peerusername];
                    if(iceconnectionstate !== "closed"){
                        peer.close();
                    }
                    
                }

            });
            peer.addEventListener('icecandidate',(event)=> {
                
                if(event.candidate!==null){
                    return;

                }
                signal('new-answer',{sdp:peer.localDescription,'reciver_channel_name':reciver_ch})


            });
            peer.setRemoteDescription(offer).then(()=> {
                console.log("remote description set sucessfully for %s", peerusername);
                return peer.createAnswer();
            }).then(a=>{
                console.log("answer created");
                peer.setLocalDescription(a)
            });
1
        }
        // helper function for create answer on recive message 
        function onrecmessagefilehandler(event){
            console.log(`Received message is of bytes ${event.data.byteLength}`);
            receiveBuffer.push(event.data);
            recivedsize+=event.data.byteLength;
            //console.log(event);
            console.log(rec_filesize,rec_filesize)
            receiveProgress.value = recivedsize;
            console.log(rec_filesize,recivedsize);
            if (recivedsize === rec_filesize) {
                const received = new Blob(receiveBuffer);
                receiveBuffer = [];

                downloadAnchor.href = URL.createObjectURL(received);
                downloadAnchor.download = filename;
                downloadAnchor.textContent =`Click to download '${filename}' (${rec_filesize} bytes)`;
                downloadAnchor.style.display = 'block';
            }



        }
        //small function crutial for communication with websocket
        function signal(action,message){
            var jsonstr=JSON.stringify({
            'peer':userName,
            'action':action,
            'message':message,
            

            });
            chatSocket.send(jsonstr);
        }
        function handler(data){
            console.log(data);
            if(data["action"]==="file-size"){
                console.log(`we have detected the buffer of file size ${data["file-size"]}`);
                rec_filesize=data["file-size"];
                filename=data["file-name"];
                receiveProgress.max=rec_filesize
            }
            else if(data["action"]==="file"){
                onrecmessage(data["file"]);
            }
        }
        
        //const fileInput = document.querySelector('input#fileInput');
        
        //fileInput.addEventListener('change', handleFileInputChange, false);
        
        
    </script>
</body>
</html>